{
    "author": "Lukas Reiter", 
    "plugins": [
        0, 
        6, 
        7
    ], 
    "burp_professional_only": false, 
    "uuid": "fcfbfcaa-e902-4469-bc75-0c5634d4571a", 
    "version": "v1.0", 
    "script": "\"\"\"\nThis script searches all in-scope HTTP responses for JWTs. If a JWT is found, then it determines if one of the\nHTTP request parameters is located inside the JWT.\n\nUse this script to identify HTTP request parameters that might allow tampering the content of the JWT content.\n\"\"\"\nimport re\nimport os\nimport json\nimport traceback\n\n# Do the initial setup\nif ref == 1 or \"jwt_regex\" not in session or \"dedup\" not in session:\n\tsession[\"jwt_regex\"] = re.compile(\"(?P<jwt>eyJ\\w+\\.eyJ\\w+\\.\\w+)\")\n\theader = [\"Ref.\", \"URL\", \"Type\", \"Name\", \"Value\", \"JWT\", \"Path to JWT attribute\"]\n\tsession[\"dedup\"] = {}\n\ndef get_jwts(content):\n\t\"\"\"\n\tThis method implements the core functionality to extract information from requests or responses based on\n\tthe given regular expressions.\n\t\"\"\"\n\tglobal session\n\tresult = []\n\tfor match in session[\"jwt_regex\"].finditer(content):\r\n\t\tif has_stopped():\r\n\t\t\tbreak\n\t\tresult.append(match.group(\"jwt\"))\n\treturn result\n\ndef search_json(content, search_string, path = \"/\"):\n\t\"\"\"\n\tThis method recursively searches the given JSON object for the given value.\n\t\"\"\"\n\tresult = []\n\tif isinstance(content, dict):\n\t\tfor key, value in content.items():\r\n\t\t\tif has_stopped():\r\n\t\t\t\tbreak\n\t\t\tresult += search_json(value, search_string, os.path.join(path, unicode(key)))\n\telif isinstance(content, list):\n\t\tfor item in content:\r\n\t\t\tif has_stopped():\r\n\t\t\t\tbreak\n\t\t\tresult += search_json(item, search_string, path)\n\telif search_string in content:\n\t\tresult.append(unicode(path))\n\treturn result\n\n# Process only in-scope HTTP requests and responses\nresponse = message_info.getResponse()\nif in_scope and response:\n\ttry:\n\t\tjwts = get_jwts(unicode(helpers.bytesToString(response)))\n\t\tfor jwt in jwts:\n\t\t\ttoken = decode_jwt(jwt)\n\t\t\tjwt_payload = token[1]\r\n\t\t\tif has_stopped():\r\n\t\t\t\tbreak\n\t\t\telif jwt_payload:\n\t\t\t\tjson_object = json.JSONDecoder().decode(jwt_payload)\n\t\t\t\tfor parameter in request_info.getParameters():\r\n\t\t\t\t\tif has_stopped():\r\n\t\t\t\t\t\tbreak\n\t\t\t\t\tfor path in search_json(json_object, parameter.getValue()):\r\n\t\t\t\t\t\tif has_stopped():\r\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\trows.append([ref, url, get_parameter_name(parameter.getType()), parameter.getName(), parameter.getValue(), jwt, path])\n\texcept:\n\t\ttraceback.print_exc(file=callbacks.getStderr())", 
    "name": "JWT - Template Script to Identify Potential Request Parameters That Allow JWT Tampering"
}